// src/lib/services/solitonMemory.ts
import { writable, get } from 'svelte/store';
import { browser } from '$app/environment';

// Memory stats store for reactive updates
export const memoryStats = writable({
  totalMemories: 0,
  activeWaves: 0,
  averageStrength: 0,
  clusterCount: 0,
  lastUpdated: null as Date | null
});

// Phase information for Ghost AI
export const currentPhase = writable('idle');
export const phaseAmplitude = writable(0);
export const phaseFrequency = writable(0);
export const phaseCoherence = writable(0);

// Sensitive content detection
export const sensitiveContentDetected = writable(false);

// Configuration
const CONFIG = {
  BACKEND_URL: '/api/soliton',
  VECTOR_DIMENSION: 128,
  STORAGE_KEY: 'tori_soliton_memory',
  RESONANCE_THRESHOLD: 0.6,
  // Force backend as primary, only use fallback if explicitly enabled
  ALLOW_FALLBACK: import.meta.env.VITE_ALLOW_MEMORY_FALLBACK === 'true',
  DEBUG: import.meta.env.DEV
};

// Types
interface MemoryEntry {
  id: string;
  content: string;
  embedding: number[];
  strength: number;
  timestamp: Date;
  tags: string[];
  phase?: string;
  valence?: number;
  amplitude?: number;
  frequency?: number;
}

interface MemoryStats {
  totalMemories: number;
  activeWaves: number;
  averageStrength: number;
  clusterCount: number;
  lastUpdated: Date | null;
}

interface PhaseChangeEvent {
  userId: string;
  phase: string;
  amplitude: number;
  frequency: number;
  coherence?: number;
}

// Local memory cache
let localMemoryCache: MemoryEntry[] = [];
let userId: string | null = null;
let isInitialized = false;

// Rate limiting for failed requests
let lastStatsFailure = 0;
const STATS_RETRY_COOLDOWN = 30000; // 30 seconds

/**
 * Initialize Soliton Memory for a specific user
 * @param uid User ID to initialize memory for
 */
export async function initializeUserMemory(uid: string): Promise<boolean> {
  if (!uid) {
    console.error('ðŸŒŠ Soliton Memory Error: Cannot initialize with empty userId');
    return false;
  }

  userId = uid;
  console.log(`ðŸŒŠ Soliton Memory: Initializing for user ${userId}`);

  try {
    // Initialize on backend first
    const requestBody = { userId: uid };
    console.log('ðŸŒŠ Soliton Memory: Sending init request:', requestBody);
    
    const response = await fetch(`${CONFIG.BACKEND_URL}/init`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('ðŸŒŠ Soliton Memory: Init failed:', response.status, errorText);
      throw new Error(`Backend initialization failed: ${response.status}`);
    }

    const result = await response.json();
    
    if (result.success) {
      console.log('ðŸŒŠ Soliton Memory: Backend initialization successful');
      
      // Load from localStorage as a supplement if available
      if (browser) {
        loadFromLocalStorage();
      }
      
      isInitialized = true;
      
      // Update memory stats - but don't fail init if stats fail
      fetchMemoryStats(uid).catch(err => {
        console.warn('ðŸŒŠ Soliton Memory: Stats fetch failed during init:', err);
      });
      
      return true;
    } else {
      throw new Error(result.error || 'Unknown initialization error');
    }
  } catch (error) {
    console.error('ðŸŒŠ Soliton Memory Error:', error);
    
    // Only use fallback if explicitly enabled in environment
    if (CONFIG.ALLOW_FALLBACK && browser) {
      console.warn('ðŸŒŠ Soliton Memory: Using fallback mode (LOCAL ONLY - NO PERSISTENCE)');
      loadFromLocalStorage();
      isInitialized = true;
      return true;
    }
    
    return false;
  }
}

/**
 * Store a memory in the Soliton system
 * @param id Unique identifier for the memory
 * @param content The text content of the memory
 * @param strength Memory strength (0-1)
 * @param tags Array of tags for categorization
 */
export async function storeMemory(
  id: string,
  content: string,
  strength: number = 0.7,
  tags: string[] = []
): Promise<boolean> {
  if (!isInitialized || !userId) {
    console.error('ðŸŒŠ Soliton Memory Error: Not initialized. Call initializeUserMemory first.');
    return false;
  }

  // Generate embedding, valence, and phase metrics for the content
  const embedding = await generateEmbedding(content);
  const valence = analyzeValence(content);
  const { phase, amplitude, frequency } = extractPhaseTags(content);

  const memoryEntry: MemoryEntry = {
    id,
    content,
    embedding,
    strength,
    timestamp: new Date(),
    tags,
    phase,
    valence,
    amplitude,
    frequency
  };

  try {
    // Always try backend first
    const response = await fetch(`${CONFIG.BACKEND_URL}/store`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        user: userId,
        concept_id: memoryEntry.id,
        content: memoryEntry.content,
        activation_strength: memoryEntry.strength
      }),
    });

    if (!response.ok) {
      throw new Error(`Backend store failed: ${response.status}`);
    }

    const result = await response.json();
    
    if (result.success) {
      // Update local cache as well for quick access
      addToLocalCache(memoryEntry);
      saveToLocalStorage();
      
      // Update memory stats
      await fetchMemoryStats(userId);
      
      return true;
    } else {
      throw new Error(result.error || 'Unknown storage error');
    }
  } catch (error) {
    console.error('ðŸŒŠ Soliton Memory Error:', error);
    
    // Only use fallback if explicitly enabled
    if (CONFIG.ALLOW_FALLBACK && browser) {
      console.warn('ðŸŒŠ Soliton Memory: Memory storage failed on backend, using local only');
      addToLocalCache(memoryEntry);
      saveToLocalStorage();
      return true;
    }
    
    return false;
  }
}

/**
 * Find memories related to a query by phase and semantic similarity
 * @param query The query text to find related memories for
 * @param limit Maximum number of results
 * @param minStrength Minimum memory strength to consider
 */
export async function findRelatedMemories(
  query: string,
  limit: number = 5,
  minStrength: number = 0.3
): Promise<MemoryEntry[]> {
  if (!isInitialized || !userId) {
    console.error('ðŸŒŠ Soliton Memory Error: Not initialized');
    return [];
  }
  
  try {
    // Try backend first for comprehensive search
    const response = await fetch(`${CONFIG.BACKEND_URL}/recall`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userId,
        query,
        limit,
        minStrength
      }),
    });

    if (!response.ok) {
      throw new Error(`Backend recall failed: ${response.status}`);
    }

    const result = await response.json();
    
    if (result.success && result.memories) {
      return result.memories;
    } else {
      throw new Error(result.error || 'Unknown recall error');
    }
  } catch (error) {
    console.error('ðŸŒŠ Soliton Memory Error:', error);
    
    // Only use fallback if explicitly enabled
    if (CONFIG.ALLOW_FALLBACK && browser) {
      console.warn('ðŸŒŠ Soliton Memory: Recall from backend failed, using local cache');
      return findRelatedInLocalCache(query, limit, minStrength);
    }
    
    return [];
  }
}

/**
 * Fetch memory statistics for a user
 * @param uid User ID to fetch stats for
 */
export async function fetchMemoryStats(uid: string): Promise<MemoryStats | null> {
  if (!uid) return null;
  
  // Rate limit failed requests to prevent cascading 500s
  const now = Date.now();
  if (lastStatsFailure > 0 && now - lastStatsFailure < STATS_RETRY_COOLDOWN) {
    console.log('ðŸŒŠ Soliton Memory: Skipping stats fetch due to recent failure');
    return get(memoryStats); // Return cached stats
  }
  
  // Convert display name to slug format (e.g., "Admin User" -> "adminuser")
  const userSlug = uid.replace(/\s+/g, '').toLowerCase();
  console.log('ðŸŒŠ Soliton Memory: Fetching stats for slug:', userSlug);
  
  try {
    const response = await fetch(`${CONFIG.BACKEND_URL}/stats/${userSlug}`);
    
    if (!response.ok) {
      lastStatsFailure = now;
      const errorText = await response.text();
      console.error('ðŸŒŠ Soliton Memory: Stats failed:', response.status, errorText);
      throw new Error(`Backend stats fetch failed: ${response.status}`);
    }
    
    const result = await response.json();
    
    if (result.success || result.totalMemories !== undefined) {
      // Reset failure timestamp on success
      lastStatsFailure = 0;
      
      // Update the store with latest stats
      const stats = result.stats || result;
      memoryStats.set({
        totalMemories: stats.totalMemories || 0,
        activeWaves: stats.activeWaves || 0,
        averageStrength: stats.averageStrength || 0,
        clusterCount: stats.clusterCount || 0,
        lastUpdated: new Date()
      });
      
      return get(memoryStats);
    } else {
      throw new Error(result.error || 'Unknown stats error');
    }
  } catch (error) {
    console.error('ðŸŒŠ Soliton Memory Error:', error);
    
    // Only use fallback if explicitly enabled
    if (CONFIG.ALLOW_FALLBACK && browser) {
      console.warn('ðŸŒŠ Soliton Memory: Stats fetch from backend failed, using local estimates');
      const localStats = calculateLocalStats();
      memoryStats.set(localStats);
      return localStats;
    }
    
    return null;
  }
}

/**
 * Notify the system of a phase change in the Ghost AI
 * @param event Phase change event details
 */
/**
 * List memories whose concept path starts with a prefix.
 * Returns raw MemoryEntry records (caller can JSON.parse content if needed).
 */
export async function listMemoriesByPrefix(prefix: string): Promise<MemoryEntry[]> {
  if (!isInitialized || !userId) {
    console.error('ðŸŒŠ Soliton Memory Error: Not initialized');
    return [];
  }
  
  try {
    // Try backend first
    const response = await fetch(`${CONFIG.BACKEND_URL}/list-by-prefix`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userId,
        prefix
      }),
    });

    if (!response.ok) {
      throw new Error(`Backend list-by-prefix failed: ${response.status}`);
    }

    const result = await response.json();
    
    if (result.success && result.memories) {
      return result.memories;
    } else {
      throw new Error(result.error || 'Unknown list-by-prefix error');
    }
  } catch (error) {
    console.error('ðŸŒŠ Soliton Memory Error:', error);
    
    // Only use fallback if explicitly enabled
    if (CONFIG.ALLOW_FALLBACK && browser) {
      console.warn('ðŸŒŠ Soliton Memory: List-by-prefix from backend failed, using local cache');
      // Filter local cache by checking if ID starts with prefix
      return localMemoryCache.filter(mem => mem.id.startsWith(prefix));
    }
    
    return [];
  }
}

export async function phaseChangeEvent(event: PhaseChangeEvent): Promise<boolean> {
  if (!isInitialized || !userId) {
    console.error('ðŸŒŠ Soliton Memory Error: Not initialized');
    return false;
  }
  
  // Update local phase stores
  currentPhase.set(event.phase);
  phaseAmplitude.set(event.amplitude);
  phaseFrequency.set(event.frequency);
  if (event.coherence) phaseCoherence.set(event.coherence);
  
  try {
    // Notify the backend
    const response = await fetch(`${CONFIG.BACKEND_URL}/phase-change`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userId,
        ...event
      }),
    });

    if (!response.ok) {
      throw new Error(`Backend phase notification failed: ${response.status}`);
    }

    const result = await response.json();
    
    if (result.success) {
      console.log(`ðŸŒŠ Ghost AI Phase Change: ${event.phase} (amplitude: ${event.amplitude.toFixed(2)}, frequency: ${event.frequency.toFixed(2)})`);
      return true;
    } else {
      throw new Error(result.error || 'Unknown phase notification error');
    }
  } catch (error) {
    console.error('ðŸŒŠ Soliton Memory Error:', error);
    
    // Even if backend notification fails, we've updated local state
    console.warn('ðŸŒŠ Ghost AI Phase Change (local only):', event.phase);
    return false;
  }
}

/**
 * Analyze the emotional valence of text content
 * @param text Text to analyze
 * @returns Emotional valence score (-1 to 1)
 */
export function analyzeValence(text: string): number {
  // Simplified valence analysis - in production this would use a more sophisticated algorithm
  // Positive/negative word lists with weighting
  const positiveWords = ['good', 'great', 'excellent', 'happy', 'joy', 'love', 'like', 'wonderful', 'beautiful'];
  const negativeWords = ['bad', 'terrible', 'awful', 'sad', 'hate', 'dislike', 'horrible', 'ugly', 'angry'];
  
  const lowerText = text.toLowerCase();
  let score = 0;
  
  // Count positive and negative words
  positiveWords.forEach(word => {
    const regex = new RegExp(`\\b${word}\\b`, 'gi');
    const matches = lowerText.match(regex);
    if (matches) score += matches.length * 0.1;
  });
  
  negativeWords.forEach(word => {
    const regex = new RegExp(`\\b${word}\\b`, 'gi');
    const matches = lowerText.match(regex);
    if (matches) score -= matches.length * 0.1;
  });
  
  // Clamp to range [-1, 1]
  return Math.max(-1, Math.min(1, score));
}

/**
 * Extract phase tags from content
 * @param text Text to analyze
 * @returns Phase information
 */
export function extractPhaseTags(text: string): { phase: string; amplitude: number; frequency: number } {
  // Simplified phase detection - would be more sophisticated in production
  const lowerText = text.toLowerCase();
  
  // Default values
  let phase = 'neutral';
  let amplitude = 0.5;
  let frequency = 0.5;
  
  // Very basic phase detection based on keywords
  if (lowerText.includes('question') || lowerText.includes('?')) {
    phase = 'inquiry';
    amplitude = 0.7;
    frequency = 0.4;
  } else if (lowerText.includes('error') || lowerText.includes('wrong') || lowerText.includes('mistake')) {
    phase = 'correction';
    amplitude = 0.8;
    frequency = 0.3;
  } else if (lowerText.includes('thanks') || lowerText.includes('thank you')) {
    phase = 'appreciation';
    amplitude = 0.6;
    frequency = 0.7;
  } else if (lowerText.includes('help') || lowerText.includes('assist')) {
    phase = 'assistance';
    amplitude = 0.7;
    frequency = 0.6;
  } else if (lowerText.length > 100) {
    // Longer text tends to be more informative
    phase = 'information';
    amplitude = 0.5;
    frequency = 0.5;
  }
  
  // Add some randomness for natural variation
  amplitude = Math.min(1, Math.max(0, amplitude + (Math.random() * 0.2 - 0.1)));
  frequency = Math.min(1, Math.max(0, frequency + (Math.random() * 0.2 - 0.1)));
  
  return { phase, amplitude, frequency };
}

/**
 * Measure the amplitude of a memory based on content and context
 * @param text Content to analyze
 * @returns Amplitude value (0-1)
 */
export function measureAmplitude(text: string): number {
  // Simplified amplitude measurement based on text characteristics
  // In production, this would use more sophisticated NLP
  
  // Length factor - longer texts have higher potential amplitude
  const lengthFactor = Math.min(1, text.length / 500);
  
  // Emotion factor - stronger emotions have higher amplitude
  const valence = analyzeValence(text);
  const emotionFactor = Math.abs(valence);
  
  // Complexity factor - more complex thoughts have higher amplitude
  const words = text.split(/\s+/).length;
  const uniqueWords = new Set(text.toLowerCase().split(/\s+/)).size;
  const complexityFactor = Math.min(1, uniqueWords / words * 2);
  
  // Combine factors with weights
  return 0.3 * lengthFactor + 0.4 * emotionFactor + 0.3 * complexityFactor;
}

/**
 * Estimate the frequency of a memory based on content patterns
 * @param text Content to analyze
 * @returns Frequency value (0-1)
 */
export function estimateFrequency(text: string): number {
  // Simplified frequency estimation
  // In production, would use more sophisticated linguistic analysis
  
  // Shorter sentences tend to have higher frequency
  const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
  const avgSentenceLength = text.length / (sentences.length || 1);
  const sentenceFactor = Math.max(0, 1 - avgSentenceLength / 100);
  
  // Questions tend to have higher frequency
  const questionFactor = text.includes('?') ? 0.7 : 0.4;
  
  // Repetition indicates higher frequency
  const words = text.toLowerCase().split(/\s+/);
  const wordCounts = new Map<string, number>();
  words.forEach(word => {
    wordCounts.set(word, (wordCounts.get(word) || 0) + 1);
  });
  
  let repetitionCount = 0;
  wordCounts.forEach(count => {
    if (count > 1) repetitionCount += count - 1;
  });
  
  const repetitionFactor = Math.min(1, repetitionCount / words.length);
  
  // Combine factors with weights
  return 0.4 * sentenceFactor + 0.3 * questionFactor + 0.3 * repetitionFactor;
}

// Helper functions for local memory operations

/**
 * Generate a simple embedding vector for text
 * @param text Text to generate embedding for
 * @returns Embedding vector
 */
async function generateEmbedding(text: string): Promise<number[]> {
  try {
    // Try to get a real embedding from the backend
    const response = await fetch(`${CONFIG.BACKEND_URL}/embed`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text }),
    });

    if (response.ok) {
      const result = await response.json();
      if (result.success && result.embedding) {
        return result.embedding;
      }
    }
  } catch (error) {
    console.warn('ðŸŒŠ Soliton Memory: Embedding generation on backend failed, using fallback method');
  }
  
  // Fallback to a simple hash-based pseudo-embedding if backend fails
  // This is NOT a real embedding, just a placeholder for development
  const embedding = new Array(CONFIG.VECTOR_DIMENSION).fill(0);
  
  // Simple hash of the text to seed the embedding
  let hash = 0;
  for (let i = 0; i < text.length; i++) {
    hash = ((hash << 5) - hash) + text.charCodeAt(i);
    hash = hash & hash; // Convert to 32bit integer
  }
  
  // Use the hash to seed a simple pseudo-random pattern
  for (let i = 0; i < CONFIG.VECTOR_DIMENSION; i++) {
    // Create a deterministic but seemingly random value between -1 and 1
    embedding[i] = Math.sin(hash + i * 0.1) * 0.5 + Math.cos(i * 0.1) * 0.5;
  }
  
  // Normalize the vector
  const magnitude = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));
  return embedding.map(val => val / magnitude);
}

/**
 * Find related memories in the local cache
 */
function findRelatedInLocalCache(query: string, limit: number, minStrength: number): MemoryEntry[] {
  // Filter by strength first
  const candidates = localMemoryCache.filter(mem => mem.strength >= minStrength);
  if (candidates.length === 0) return [];
  
  // Generate query embedding using fallback method if needed
  const queryEmbedding = generateEmbeddingSync(query);
  
  // Calculate cosine similarity with each memory
  const withSimilarity = candidates.map(mem => {
    const similarity = cosineSimilarity(queryEmbedding, mem.embedding);
    return { ...mem, similarity };
  });
  
  // Sort by similarity (descending) and return top results
  return withSimilarity
    .sort((a, b) => b.similarity - a.similarity)
    .slice(0, limit);
}

/**
 * Calculate cosine similarity between two vectors
 */
function cosineSimilarity(vecA: number[], vecB: number[]): number {
  if (vecA.length !== vecB.length) return 0;
  
  let dotProduct = 0;
  let magnitudeA = 0;
  let magnitudeB = 0;
  
  for (let i = 0; i < vecA.length; i++) {
    dotProduct += vecA[i] * vecB[i];
    magnitudeA += vecA[i] * vecA[i];
    magnitudeB += vecB[i] * vecB[i];
  }
  
  magnitudeA = Math.sqrt(magnitudeA);
  magnitudeB = Math.sqrt(magnitudeB);
  
  if (magnitudeA === 0 || magnitudeB === 0) return 0;
  
  return dotProduct / (magnitudeA * magnitudeB);
}

/**
 * Synchronous version of generateEmbedding for local cache operations
 */
function generateEmbeddingSync(text: string): number[] {
  // Simple hash-based pseudo-embedding, same as the fallback in the async version
  const embedding = new Array(CONFIG.VECTOR_DIMENSION).fill(0);
  
  let hash = 0;
  for (let i = 0; i < text.length; i++) {
    hash = ((hash << 5) - hash) + text.charCodeAt(i);
    hash = hash & hash;
  }
  
  for (let i = 0; i < CONFIG.VECTOR_DIMENSION; i++) {
    embedding[i] = Math.sin(hash + i * 0.1) * 0.5 + Math.cos(i * 0.1) * 0.5;
  }
  
  const magnitude = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));
  return embedding.map(val => val / magnitude);
}

/**
 * Add a memory entry to the local cache
 */
function addToLocalCache(entry: MemoryEntry): void {
  // Remove any existing entry with the same ID
  localMemoryCache = localMemoryCache.filter(mem => mem.id !== entry.id);
  
  // Add the new entry
  localMemoryCache.push(entry);
  
  // Sort by timestamp (newest first)
  localMemoryCache.sort((a, b) => {
    return new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime();
  });
  
  // Cap the cache size to prevent memory issues
  const MAX_CACHE_SIZE = 1000;
  if (localMemoryCache.length > MAX_CACHE_SIZE) {
    localMemoryCache = localMemoryCache.slice(0, MAX_CACHE_SIZE);
  }
}

/**
 * Calculate memory statistics from local cache
 */
function calculateLocalStats(): MemoryStats {
  if (localMemoryCache.length === 0) {
    return {
      totalMemories: 0,
      activeWaves: 0,
      averageStrength: 0,
      clusterCount: 0,
      lastUpdated: new Date()
    };
  }
  
  // Basic stats from local cache
  const totalMemories = localMemoryCache.length;
  
  // Memories with strength above threshold are considered "active"
  const activeWaves = localMemoryCache.filter(mem => mem.strength >= 0.5).length;
  
  // Average strength calculation
  const averageStrength = localMemoryCache.reduce((sum, mem) => sum + mem.strength, 0) / totalMemories;
  
  // Estimate cluster count using a simple approach
  // In production, this would use actual clustering algorithms
  const uniqueTags = new Set<string>();
  localMemoryCache.forEach(mem => {
    mem.tags.forEach(tag => uniqueTags.add(tag));
  });
  
  const clusterCount = Math.min(uniqueTags.size, Math.ceil(totalMemories / 5));
  
  return {
    totalMemories,
    activeWaves,
    averageStrength,
    clusterCount,
    lastUpdated: new Date()
  };
}

/**
 * Load memory cache from localStorage
 */
function loadFromLocalStorage(): void {
  if (!browser) return;
  
  try {
    const storageKey = `${CONFIG.STORAGE_KEY}_${userId}`;
    const storedData = localStorage.getItem(storageKey);
    
    if (storedData) {
      const parsed = JSON.parse(storedData);
      
      // Validate the data structure
      if (Array.isArray(parsed)) {
        localMemoryCache = parsed.map(item => ({
          ...item,
          // Ensure timestamp is a Date object
          timestamp: new Date(item.timestamp)
        }));
        
        console.log(`ðŸŒŠ Soliton Memory: Loaded ${localMemoryCache.length} memories from localStorage`);
      }
    }
  } catch (error) {
    console.error('ðŸŒŠ Soliton Memory: Error loading from localStorage', error);
    // Reset to empty if corrupted
    localMemoryCache = [];
  }
}

/**
 * Save memory cache to localStorage
 */
function saveToLocalStorage(): void {
  if (!browser || !userId) return;
  
  try {
    const storageKey = `${CONFIG.STORAGE_KEY}_${userId}`;
    localStorage.setItem(storageKey, JSON.stringify(localMemoryCache));
  } catch (error) {
    console.error('ðŸŒŠ Soliton Memory: Error saving to localStorage', error);
  }
}

/**
 * Log an event to the Write-Ahead Log (WAL)
 * @param event Event to log to WAL
 */
export async function logEventToWal(event: any): Promise<boolean> {
  if (!isInitialized || !userId) {
    console.error('ðŸŒŠ Soliton Memory Error: Not initialized');
    return false;
  }
  
  try {
    const response = await fetch('/api/mesh/wal', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userId,
        event
      }),
    });

    if (!response.ok) {
      throw new Error(`WAL logging failed: ${response.status}`);
    }

    const result = await response.json();
    return result.success || false;
  } catch (error) {
    console.error('ðŸŒŠ WAL Error:', error);
    return false;
  }
}

// Export additional utilities for testing or advanced usage
export const solitonMemory = {
  initializeUserMemory,
  storeMemory,
  findRelatedMemories,
  fetchMemoryStats,
  phaseChangeEvent,
  analyzeValence,
  extractPhaseTags,
  measureAmplitude,
  estimateFrequency
};

// Add missing vaultMemory export
export const vaultMemory = async (
  conceptId: string,
  vaultLevel: string = 'UserSealed'
): Promise<boolean> => {
  if (!isInitialized || !userId) {
    console.error('ðŸŒŠ Soliton Memory Error: Not initialized');
    return false;
  }
  
  try {
    const response = await fetch(`${CONFIG.BACKEND_URL}/vault/${userId}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        conceptId,
        vaultLevel
      }),
    });

    if (!response.ok) {
      throw new Error(`Vault failed: ${response.status}`);
    }

    const result = await response.json();
    return result.success || false;
  } catch (error) {
    console.error('ðŸŒŠ Vault Error:', error);
    return false;
  }
};

export default solitonMemory;
